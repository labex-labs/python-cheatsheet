---
title: 'Основы ООП на Python - Шпаргалка по Python'
description: 'Объектно-ориентированное программирование (ООП) — это парадигма, основанная на концепции объектов, которые являются экземплярами классов. Принципы ООП — это фундаментальные концепции, управляющие проектированием и разработкой программного обеспечения в объектно-ориентированном стиле. В Python ООП поддерживается использованием классов и объектов. Вот некоторые основные принципы ООП в Python'
labUrl: 'https://labex.io/ru/labs/python-python-oop-basics-633662?course=python-cheatsheet'
---

<base-title :title="frontmatter.title" :description="frontmatter.description">
Основы ООП на Python
</base-title>

<base-lab-url :url="frontmatter.labUrl" />

<base-disclaimer>
  <base-disclaimer-title>
    <a href="https://en.wikipedia.org/wiki/Object-oriented_programming">Объектно-ориентированное программирование</a>
  </base-disclaimer-title>
  <base-disclaimer-content>
    Объектно-ориентированное программирование (ООП) — это парадигма программирования, основанная на концепции «объектов», которые могут содержать данные и код. Данные принимают форму полей (часто известных как атрибуты или свойства), а код — форму процедур (часто известных как методы).
  </base-disclaimer-content>
</base-disclaimer>

## Инкапсуляция

Инкапсуляция — одна из фундаментальных концепций объектно-ориентированного программирования, которая помогает защитить данные и методы объекта от несанкционированного доступа и изменения. Это способ достижения абстракции данных, что означает сокрытие деталей реализации объекта от внешнего мира и предоставление только необходимой информации.

В Python инкапсуляция может быть достигнута с помощью модификаторов доступа. Модификаторы доступа — это ключевые слова, определяющие доступность атрибутов и методов в классе. Три модификатора доступа, доступные в Python, — это public (публичный), private (приватный) и protected (защищенный). Однако в Python нет явного способа определения модификаторов доступа, как в некоторых других языках программирования, таких как Java и C++. Вместо этого он использует соглашение об использовании префиксов подчеркивания для обозначения уровня доступа.

В приведенном примере кода класс `MyClass` имеет два атрибута: `_protected_var` и `__private_var`. `_protected_var` помечен как защищенный с помощью префикса из одного подчеркивания. Это означает, что атрибут может быть доступен внутри класса и его подклассов, но не за пределами класса. `__private_var` помечен как приватный с помощью префикса из двух подчеркиваний. Это означает, что атрибут может быть доступен только внутри класса и не за его пределами, даже в его подклассах.

Когда мы создаем объект класса `MyClass`, мы можем получить доступ к атрибуту `_protected_var`, используя имя объекта с префиксом из одного подчеркивания. Однако мы не можем получить доступ к атрибуту `__private_var` с помощью имени объекта, так как он скрыт от внешнего мира. Если мы попытаемся получить доступ к атрибуту `__private_var`, мы получим `AttributeError`, как показано в коде.

Таким образом, инкапсуляция является важной концепцией в объектно-ориентированном программировании, которая помогает защитить детали реализации объекта. В Python мы можем достичь инкапсуляции, используя модификаторы доступа и префиксы подчеркивания для обозначения уровня доступа.

```python
# Определяем класс с именем MyClass
class MyClass:

    # Конструктор, который инициализирует объект класса
    def __init__(self):

        # Определяем защищенную переменную с начальным значением 10
        # Имя переменной начинается с одного подчеркивания, что указывает на защищенный доступ
        self._protected_var = 10

        # Определяем приватную переменную с начальным значением 20
        # Имя переменной начинается с двух подчеркиваний, что указывает на приватный доступ
        self.__private_var = 20

# Создаем объект класса MyClass
obj = MyClass()

# Получаем доступ к защищенной переменной, используя имя объекта, и выводим ее значение
# Защищенная переменная может быть доступна за пределами класса, но
# она предназначена для использования внутри класса или его подклассов
print(obj._protected_var)   # output: 10

# Пытаемся получить доступ к приватной переменной, используя имя объекта, и выводим ее значение
# Приватная переменная не может быть доступна за пределами класса, даже его подклассами
# Это вызовет AttributeError, поскольку переменная недоступна за пределами класса
print(obj.__private_var)    # AttributeError: 'MyClass' object has no attribute '__private_var'

```

## Наследование

Наследование способствует повторному использованию кода и позволяет создавать иерархию классов, которые разделяют общие атрибуты и методы. Оно помогает создавать чистый и организованный код, сохраняя связанную функциональность в одном месте и способствуя концепции модульности. Базовый класс, от которого выводится новый класс, также известен как родительский класс, а новый класс известен как дочерний класс или подкласс.

В коде мы определяем класс `Animal`, который имеет конструктор, инициализирующий объект класса атрибутом `name`, и метод `speak`. Метод `speak` определен в классе `Animal`, но не имеет тела.

Затем мы определяем два подкласса, `Dog` и `Cat`, которые наследуются от класса `Animal`. Эти подклассы переопределяют метод `speak` класса `Animal`.

Мы создаем объект `Dog` с атрибутом имени "Rover" и объект `Cat` с атрибутом имени "Whiskers". Мы вызываем метод `speak` объекта `Dog` с помощью `dog.speak()`, и он выводит "Woof!", потому что метод `speak` класса `Dog` переопределяет метод `speak` класса `Animal`. Аналогично, мы вызываем метод `speak` объекта `Cat` с помощью `cat.speak()`, и он выводит "Meow!", потому что метод `speak` класса `Cat` переопределяет метод `speak` класса `Animal`.

```python
# Определяем класс с именем Animal
class Animal:

    # Конструктор, который инициализирует объект класса атрибутом name
    def __init__(self, name):
        self.name = name

    # Метод, определенный в классе Animal, но не имеющий тела
    # Этот метод будет переопределен в подклассах Animal
    def speak(self):
        print("")

# Определяем подкласс Dog, который наследуется от класса Animal
class Dog(Animal):

    # Переопределяем метод speak класса Animal
    def speak(self):
        print("Woof!")

# Определяем подкласс Cat, который наследуется от класса Animal
class Cat(Animal):

    # Переопределяем метод speak класса Animal
    def speak(self):
        print("Meow!")

# Создаем объект Dog с атрибутом name "Rover"
dog = Dog("Rover")

# Создаем объект Cat с атрибутом name "Whiskers"
cat = Cat("Whiskers")

# Вызываем метод speak класса Dog и выводим результат
# Метод speak класса Dog переопределяет метод speak класса Animal
# Следовательно, при вызове метода speak объекта Dog будет выведено "Woof!"
dog.speak()   # output: Woof!

# Вызываем метод speak класса Cat и выводим результат
# Метод speak класса Cat переопределяет метод speak класса Animal
# Следовательно, при вызове метода speak объекта Cat будет выведено "Meow!"
cat.speak()   # output: Meow!

```

## Полиморфизм

Полиморфизм — важная концепция в объектно-ориентированном программировании, которая позволяет писать код, способный работать с объектами разных классов единообразным образом. В Python полиморфизм достигается с помощью переопределения методов или перегрузки методов.

Переопределение метода (Method overriding) — это когда подкласс предоставляет собственную реализацию метода, который уже определен в его родительском классе. Это позволяет подклассу изменять поведение метода, не меняя его имени или сигнатуры.

Перегрузка метода (Method overloading) — это когда несколько методов имеют одинаковое имя, но разные параметры. Python не поддерживает перегрузку методов напрямую, но ее можно достичь с помощью аргументов по умолчанию или аргументов переменной длины.

Полиморфизм упрощает написание гибкого и многократно используемого кода. Он позволяет писать код, который может работать с различными объектами без необходимости знать их конкретные типы.

```python
# Класс Shape определен с абстрактным методом area, который предполагается переопределить в подклассах.
class Shape:
    def area(self):
        pass

class Rectangle(Shape):
    # Класс Rectangle определен с методом __init__, который инициализирует
    # переменные экземпляра width и height.
    # Он также определяет метод area, который вычисляет и возвращает
    # площадь прямоугольника с использованием переменных экземпляра width и height.
    def __init__(self, width, height):
        self.width = width  # Инициализация переменной экземпляра width
        self.height = height  # Инициализация переменной экземпляра height

    def area(self):
        return self.width * self.height  # Возвращает площадь прямоугольника


 # Класс Circle определен с методом __init__
 # который инициализирует переменную экземпляра radius.
 # Он также определяет метод area, который вычисляет и
 # возвращает площадь круга с использованием переменной экземпляра radius.
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius  # Инициализация переменной экземпляра radius

    def area(self):
        return 3.14 * self.radius ** 2  # Возвращает площадь круга, используя pi * r^2

# Создается список shapes с одним объектом Rectangle и одним объектом Circle. Цикл for
# перебирает каждый объект в списке и вызывает метод area каждого объекта.
# Вывод будет площадью прямоугольника (20) и площадью круга (153.86).
shapes = [Rectangle(4, 5), Circle(7)]  # Создаем список объектов Shape
for shape in shapes:
    print(shape.area())  # Выводим площадь каждого объекта Shape

```

## Абстракция

Абстракция — важная концепция в объектно-ориентированном программировании (ООП), поскольку она позволяет сосредоточиться на существенных особенностях объекта или системы, игнорируя детали, не относящиеся к текущему контексту. Уменьшая сложность и скрывая ненужные детали, абстракция может сделать код более модульным, легким для чтения и легким для сопровождения.

В Python абстракция может быть достигнута с помощью абстрактных классов или интерфейсов. Абстрактный класс — это класс, который нельзя инстанцировать напрямую, но он предназначен для наследования другими классами. Он часто включает абстрактные методы, которые не имеют реализации, но предоставляют шаблон для того, как должен быть реализован подкласс. Это позволяет программисту определить общий интерфейс для группы связанных классов, при этом позволяя каждому классу иметь свое собственное специфическое поведение.

Интерфейс, с другой стороны, представляет собой набор сигнатур методов, которые класс должен реализовать, чтобы считаться «совместимым» с интерфейсом. Интерфейсы часто используются для определения общего набора методов, которые могут реализовать несколько классов, что позволяет использовать их взаимозаменяемо в определенных контекстах.

Python не имеет встроенной поддержки абстрактных классов или интерфейсов, но их можно реализовать с помощью модуля `abc` (abstract base class). Этот модуль предоставляет класс `ABC` и декоратор `abstractmethod`, которые можно использовать для определения абстрактных классов и методов.

В целом, абстракция — это мощный инструмент для управления сложностью и улучшения качества кода в объектно-ориентированном программировании, и Python предоставляет ряд вариантов для достижения абстракции в вашем коде.

```python
# Импортируем модуль abc для определения абстрактных классов и методов
from abc import ABC, abstractmethod

# Определяем абстрактный класс Shape, который имеет абстрактный метод area
class Shape(ABC):
    @abstractmethod
    def area(self):
        pass

# Определяем класс Rectangle, который наследуется от Shape
class Rectangle(Shape):
    def __init__(self, width, height):
        self.width = width
        self.height = height

    # Реализуем метод area для Прямоугольников
    def area(self):
        return self.width * self.height

# Определяем класс Circle, который также наследуется от Shape
class Circle(Shape):
    def __init__(self, radius):
        self.radius = radius

    # Реализуем метод area для Кругов
    def area(self):
        return 3.14 * self.radius ** 2

# Создаем список фигур, который включает как Прямоугольники, так и Круги
shapes = [Rectangle(4, 5), Circle(7)]

# Перебираем каждую фигуру в списке и выводим ее площадь
for shape in shapes:
    print(shape.area())

```

Это некоторые из основных принципов ООП в Python. Эта страница в настоящее время находится в разработке, и более подробные примеры и объяснения скоро появятся.

## Соответствующие ссылки

- <router-link to="/cheatsheet/functions">Функции</router-link>
- <router-link to="/cheatsheet/decorators">Декораторы</router-link>
- <router-link to="/cheatsheet/exception-handling">Обработка исключений</router-link>
- <router-link to="/cheatsheet/dataclasses">Датаклассы</router-link>
- <router-link to="/builtin/object">object()</router-link>
- <router-link to="/builtin/classmethod">classmethod()</router-link>
- <router-link to="/builtin/staticmethod">staticmethod()</router-link>
- <router-link to="/builtin/property">property()</router-link>
- <router-link to="/builtin/isinstance">isinstance()</router-link>
- <router-link to="/builtin/issubclass">issubclass()</router-link>
- <router-link to="/builtin/super">super()</router-link>
